---
title: "Basic Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic Example}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

Population adjustment methods such as _matching-adjusted indirect comparison_ (MAIC) are increasingly used to compare marginal treatment effects when there are cross-trial differences in effect modifiers and limited patient-level data. MAIC is based on propensity score weighting, which is sensitive to poor covariate overlap and cannot extrapolate beyond the observed covariate space. Current outcome regression-based alternatives can extrapolate but target a conditional treatment effect that is incompatible in the indirect comparison. When adjusting for covariates, one must integrate or average the conditional estimate over the relevant population to recover a compatible marginal treatment effect.

We propose a marginalization method based on _parametric G-computation_ that can be easily applied where the outcome regression is a generalized linear model or a Cox model. The approach views the covariate adjustment regression as a nuisance model and separates its estimation from the evaluation of the marginal treatment effect of interest. The method can accommodate a Bayesian statistical framework, which naturally integrates the analysis into a probabilistic framework. A simulation study provides proof-of-principle and benchmarks the method's performance against MAIC and the conventional outcome regression. Parametric G-computation achieves more precise and more accurate estimates than MAIC, particularly when covariate overlap is poor, and yields unbiased marginal treatment effect estimates under no failures of assumptions. Furthermore, the marginalized regression-adjusted estimates provide greater precision and accuracy than the conditional estimates produced by the conventional outcome regression.

## General problem

Consider one _AB_ trial, for which the company has IPD, and one _AC_ trial, for which only published aggregate data are available. We wish to estimate a comparison of the effects of treatments _B_ and _C_ on an appropriate scale in some targetn
population _P_, denoted by the parameter $d_{BC(P)}$. We make use of bracketed subscripts to denote a specific population. Within the _AB_ population there are parameters $\mu_{A( AB)}$, $\mu_{B(AB)}$ and $\mu_{C(AB)}$ representing the expected outcome on each treatment (including parameters for treatments not studied in the _AB_ trial, e.g. treatment _C_). The _AB_ trial provides estimators $\bar{Y}_{A(AB)}$ and $\bar{Y}_{B(AB)}$ of $\mu_{A( AB)}$, $\mu_{B(AB)}$, respectively, which are the summary outcomes. It the same situation for the _AC_ trial.

For a suitable scale, for example a logit, or risk difference, we form estimators $\Delta_{AB(AB)}$ and $\Delta_{AC(AC)}$ of the trial level (or marginal) relative treatment effects.

$$
\Delta_{AB(AB)} = g(\bar{Y}_{B{(AB)}}) - g(\bar{Y}_{A{(AB)}})
$$

## Example analysis

First, let us load necessary packages.

```{r setup, warning=FALSE, message=FALSE}
library(boot)      # non-parametric bootstrap in MAIC and ML G-computation
library(copula)    # simulating BC covariates from Gaussian copula
library(rstanarm)  # fit outcome regression, draw outcomes in Bayesian G-computation
library(mimR)
```

### Data

Next, we load the data to use in the analysis.
The data comes from a simulation study in Remiro‐Azócar A, Heath A, Baio G (2020).
We consider binary outcomes using the log-odds ratio as the measure of effect. The binary outcome may be response to treatment or the occurrence of an adverse event.
For trials _AC_ and _BC_, outcome $y_n$ for subject $n$ is simulated from a Bernoulli distribution with probabilities of success generated from logistic regression.

For the _BC_ trial, the individual-level covariates and outcomes are aggregated to obtain summaries. The continuous covariates are summarized as means and standard deviations, which would be available to the analyst in the published study in a table of baseline characteristics in the RCT publication. The binary outcomes are summarized as overall event table. Typically, the published study only provides aggregate information to the analyst.

```{r load-data}
set.seed(555)

AC.IPD <- read.csv(here::here("raw-data", "AC_IPD.csv"))  # AC patient-level data
BC.ALD <- read.csv(here::here("raw-data", "BC_ALD.csv"))  # BC aggregate-level data
```

This general format of data sets consist of the following.

#### `AC.IPD`: Individual patient data

-   `X*`: patient measurements
-   `trt`: treatment ID
-   `y`: (logical) indicator of whether event was observed

#### `BC.ALD`: Aggregate-level data

-   `mean.X*`: mean patient measurement
-   `sd.X*`: standard deviation of patient measurement
-   `y.*.sum`: total number of events
-   `y.*.bar`: total number of events
-   `N.*`: total number of individuals

Note that the wildcard `*` here is usually an integer from 1 or the trial identifier _B_, _C_.

Our data looks like the following.

```{r}
head(AC.IPD)
```

There are 4 correlated continuous covariates generated per subject, simulated from a multivariate normal distribution.

```{r}
BC.ALD
```

In this case, we have 4 covariate mean and standard deviation values; and the event total, average and sample size for each treatment _B_, and _C_.

### Output statistics

We will implement for MAIC, STC, and G-computation methods to obtain the _marginal variance_, defined as

$$
\frac{1}{n_C} + \frac{1}{n_{\bar{C}}} + \frac{1}{n_B} + \frac{1}{n_{\bar{B}}}
$$

and the _marginal treatment effect_, defined as

$$
\log\left( \frac{n_B/(N_B-n_B)}{n_C/(N_B-n_{B})} \right) = \log(n_B n_{\bar{C}}) - \log(n_C n_{\bar{B}})
$$
where $\bar{C}$ is the compliment of $C$ so e.g. $n_{\bar{C}} = N_C - n_c$.


## Model fitting in R

The `{mimR}` package has been written to be easy to use and essential consists of a single function, `mimR()`.
This can be used to run all of the different types of model, which we will call _strategies_. The first two arguments of `mimR()` are the individual and aggregate-level data, respectively.

A `strategy` argument of `mimR` takes functions called `strategy_*()`, where the wildcard `*` is replaced by the name of the particular method required, e.g. `strategy_maic()` for MAIC. Each specific example is provided below.


### MAIC

Using the individual level data for _AC_ firstly we perform non-parametric bootstrap of the `maic.boot` function with `R` = 1000 replicates. This function fits treatment coefficient for the marginal effect for _A_ vs _C_.
The returned value is an object of class `boot` from the `{boot}` package. We then calculate the bootstrap mean and variance in the wrapper function `maic_boot_stats`.

The formula used in this model is

$$
y = X_3 + X_4 + \beta_t X_1 + \beta_t X_2
$$
which corresponds to the following `R` `formula` object passed as an argument to the strategy function.

```{r}
lin_form <- as.formula("y ~ X3 + X4 + trt*X1 + trt*X2")
```


```{r mimR_maic}
mimR_maic <- mimR(AC.IPD, BC.ALD, strategy = strategy_maic(formula = lin_form))
```

The returned object is of class `mimR`.

<!-- Wald-type normal distribution-based 95\% confidence interval are also returned. -->

```{r mimR_maic-print}
mimR_maic
```

We see that this is a list object with 3 parts, each containing statistics between each pair of treatments. These are the mean contrasts, variances and confidence intervals (CI), respectively.
The default CI is for 95% but can be altered in `mimR` with the `CI` argument.


### STC

STC is the conventional outcome regression method.
It involves fitting a regression model of outcome on treatment and covariates to the IPD.
IPD effect modifiers are centred at the mean _BC_ values.

$$
g(\mu_n) = \beta_0 + (\boldsymbol{x}_n - \boldsymbol{\theta}) \beta_1 + (\beta_z + (\boldsymbol{x_n^{EM}} - \boldsymbol{\theta^{EM}}) \boldsymbol{\beta_2}) \; \mbox{I}(z_n=1)
$$
where $\beta_0$ is the intercept, $\beta_1$ are the covariate coefficients, $\beta_z$ and $\beta_2$ are the effect modifier coefficients, $z_n$ are the indicator variables of effect alternative treatment.
$g(\cdot)$ is the link function e.g. $\log$.

As already mentioned, running the STC analysis is almost identical to the previous analysis but we now use the `strategy_stc()` strategy function instead and a formula with centered covariates.

$$
y = X_3 + X_4 + \beta_t(X_1 - \bar{X_1}) + \beta_t(X_2 - \bar{X_2})
$$
However, `mimR()` knows how to handle this so we can simply pass the same (uncentred) formula as before.

```{r mimR_stc}
mimR_stc <- mimR(AC.IPD, BC.ALD, strategy = strategy_stc(formula = lin_form))
mimR_stc
```

For the last two approaches, we perform G-computation firstly with a frequentist MLE approach and then a Bayesian approach.

### Parametric G-computation with maximum-likelihood estimation 

G-computation marginalizes the conditional estimates by separating the regression modelling from the estimation of the marginal treatment effect for _A_ versus _C_. First, a regression model of the observed outcome $y$ on the covariates $x$ and treatment $z$ is fitted to the _AC_ IPD:

$$
g(\mu_n) = \beta_0 + \boldsymbol{x}_n \boldsymbol{\beta_1} + (\beta_z + \boldsymbol{x_n^{EM}} \boldsymbol{\beta_2}) \; \mbox{I}(z_n = 1)
$$

In the context of G-computation, this regression model is often called the “Q-model.”
Having fitted the Q-model, the regression coefficients are treated as nuisance parameters. The parameters are applied to the simulated covariates $x*$ to predict hypothetical outcomes for each subject under both possible treatments. Namely, a pair of predicted outcomes, also called potential outcomes, under _A_ and under _C_, is generated for each subject.

By plugging treatment _C_ into the regression fit for every simulated observation, we predict the marginal outcome mean in the hypothetical scenario in which all units are under treatment _C_:

$$
\hat{\mu}_0 = \int_{x^*} g^{-1} (\hat{\beta}_0 + x^* \hat{\beta}_1 ) p(x^*) \; \text{d}x^*
$$

To estimate the marginal or population-average treatment effect for A versus C in the linear predictor scale, one back-transforms to this scale the average predictions, taken over all subjects on the natural outcome scale, and calculates the difference between the average linear predictions:

$$
\hat{\Delta}^{(2)}_{10} = g(\hat{\mu}_1) - g(\hat{\mu}_0)
$$


```{r mimR_gcomp_ml}
# mimR_gcomp_ml <- mimR(AC.IPD, BC.ALD, strategy = strategy_gcomp_ml(formula = lin_form))
```


### Bayesian G-computation with MCMC 

The difference between Bayesian G-computation and its maximum-likelihood counterpart is in the estimated distribution of the predicted outcomes. The Bayesian approach also marginalizes, integrates or standardizes over the joint posterior distribution of the conditional nuisance parameters of the outcome regression, as well as the joint covariate distribution.

Draw a vector of size $N^*$ of predicted outcomes $y^*_z$ under each set intervention $z^* \in \{0, 1\}$ from its posterior predictive distribution under the specific treatment. This is defined as $p(y^*_{z^*} \mid \mathcal{D}_{AC}) = \int_{\beta} p(y^*_{z^*} \mid \beta) p(\beta \mid \mathcal{D}_{AC}) d\beta$ where $p(\beta \mid \mathcal{D}_{AC})$ is the posterior distribution of the outcome regression coefficients $\beta$, which encode the predictor-outcome relationships observed in the _AC_ trial IPD. This is given by:

$$
p(y^*_{^z*} \mid \mathcal{D}_{AC}) = \int_{x^*} p(y^* \mid z^*, x^*, \mathcal{D}_{AC}) p(x^* \mid \mathcal{D}_{AC})\; \text{d}x^*
$$
$$
= \int_{x^*} \int_{\beta} p(y^* \mid z^*, x^*, \beta) p(x^* \mid \beta) p(\beta \mid \mathcal{D}_{AC})\; d\beta \; \text{d}x^*
$$

In practice, the integrals above can be approximated numerically, using full Bayesian estimation via Markov chain Monte Carlo (MCMC) sampling.

The average, variance and interval estimates of the marginal treatment effect can be derived empirically from draws of the posterior density.

We can draw a vector of size $N^*$ of predicted outcomes $y^*_z$ under each set intervention $z^*$ from its posterior predictive distribution under the specific treatment.

```{r mimR_gcomp_stan}
mimR_gcomp_stan <- mimR(AC.IPD, BC.ALD, strategy = strategy_gcomp_stan(formula = lin_form))
mimR_gcomp_stan
```

