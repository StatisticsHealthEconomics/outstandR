---
title: "Count data example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Count data example}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
  editor_options: 
  markdown: 
    wrap: 72
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  eval = TRUE,
  comment = "#>"
)
```

## Introduction

This is the vignette for performing population adjustment methods with count data, in order to compare marginal
treatment effects when there are cross-trial differences in effect modifiers and limited patient-level data.
We will demonstrate how to apply MAIC, STC, G-computation with ML, G-computation with Bayesian inference and multiple imputation marginalisation.
The document structure follow the binary data example vignette which should be referred to for more details.

## Example analysis

First, let us load necessary packages.

```{r setup, warning=FALSE, message=FALSE}
library(boot)      # non-parametric bootstrap in MAIC and ML G-computation
library(copula)    # simulating BC covariates from Gaussian copula
library(rstanarm)  # fit outcome regression, draw outcomes in Bayesian G-computation
library(outstandR)
library(tidyr)
library(simcovariates)
```

### Data

We first simulate both the IPD and ALD count data. See the binary data example vignette for more details on how this is implemented.
The difference with that example is that we change the `family` argument in `gen_data()` to `poisson(link = "log")`, corresponding to the count data case.
The `gen_data()` function is available in the [simcovariates](https://github.com/n8thangreen/simcovariates) package on GitHub.

```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(MASS)

N <- 200
allocation <- 2/3      # active treatment vs. placebo allocation ratio (2:1)
b_trt <- log(0.17)     # conditional effect of active treatment vs. common comparator
b_X <- -log(0.5)       # conditional effect of each prognostic variable
b_EM <- -log(0.67)     # conditional interaction effect of each effect modifier
meanX_AC <- c(0.45, 0.45)       # mean of normally-distributed covariate in AC trial
meanX_BC <- c(0.6, 0.6)         # mean of each normally-distributed covariate in BC
meanX_EM_AC <- c(0.45, 0.45)    # mean of normally-distributed EM covariate in AC trial
meanX_EM_BC <- c(0.6, 0.6)      # mean of each normally-distributed EM covariate in BC
sdX <- c(0.4, 0.4)     # standard deviation of each covariate (same for AC and BC)
sdX_EM <- c(0.4, 0.4)  # standard deviation of each EM covariate
corX <- 0.2            # covariate correlation coefficient  
b_0 <- -0.6            # baseline intercept coefficient  ##TODO: fixed value

ipd_trial <- gen_data(N, b_trt, b_X, b_EM, b_0,
                      meanX_AC, sdX, 
                      meanX_EM_AC, sdX_EM, 
                      corX, allocation,
                      family = poisson(link = "log"))

ipd_trial$trt <- factor(ipd_trial$trt, labels = c("C", "A"))
```

Similarly, for the aggregate data but with the additional summarise step (see binary data example vignette for code).

```{r generate-ald-data, echo=FALSE, warning=FALSE, message=FALSE}
BC.IPD <- gen_data(N, b_trt, b_X, b_EM, b_0,
                   meanX_BC, sdX, 
                   meanX_EM_BC, sdX_EM, 
                   corX, allocation,
                   family = poisson(link = "log"))

BC.IPD$trt <- factor(BC.IPD$trt, labels = c("C", "B"))

# covariate summary statistics
# assume same between treatments
cov.X <- 
  BC.IPD %>%
  as.data.frame() |> 
  dplyr::select(X1, X2, X3, X4, trt) %>%
  pivot_longer(cols = starts_with("X"), names_to = "variable", values_to = "value") %>%
  group_by(variable) %>%
  summarise(
    mean = mean(value),
    sd = sd(value)
  ) %>%
  pivot_longer(cols = c("mean", "sd"), names_to = "statistic", values_to = "value") %>%
  ungroup() |> 
  mutate(trt = NA)

# outcome
summary.y <- 
  BC.IPD |> 
  as.data.frame() |> 
  dplyr::select(y, trt) %>%
  pivot_longer(cols = "y", names_to = "variable", values_to = "value") %>%
  group_by(variable, trt) %>%
  summarise(
    mean = mean(value),
    sd = sd(value),
    sum = sum(value),
  ) %>%
  pivot_longer(cols = c("mean", "sd", "sum"),
               names_to = "statistic", values_to = "value") %>%
  ungroup()

# sample sizes
summary.N <- 
  BC.IPD |> 
  group_by(trt) |> 
  count(name = "N") |> 
  pivot_longer(cols = "N", names_to = "statistic", values_to = "value") |> 
  mutate(variable = NA_character_) |> 
  dplyr::select(variable, statistic, value, trt)
  
ald_trial <- rbind.data.frame(cov.X, summary.y, summary.N)
```

This general format of the data sets are in a 'long' style consisting of the following.

#### `ipd_trial`: Individual patient data

-   `X*`: Patient measurements
-   `trt`: Treatment label (factor)
-   `y`: Counts

#### `ald_trial`: Aggregate-level data

-   `variable`: Covariate name. In the case of treatment arm sample size
    this is `NA`
-   `statistic`: Summary statistic name from mean, standard deviation or
    sum
-   `value`: Numerical value of summary statistic
-   `trt`: Treatment label. Because we assume a common covariate
    distribution between treatment arms this is `NA`

Our data look like the following.

```{r}
head(ipd_trial)
```

There are 4 correlated continuous covariates generated per subject,
simulated from a multivariate normal distribution. Treatment `trt` takes
either new treatment *A* or standard of care / status quo *C*. The ITC
is 'anchored' via *C*, the common treatment.

```{r}
ald_trial
```

In this case, we have 4 covariate mean and standard deviation values;
and the total, average and sample size for each treatment *B* and
*C*.

In the following we will implement for MAIC, STC, and G-computation methods to obtain the
*marginal variance* and the *marginal treatment effect*.

## Model fitting in R

The `{outstandR}` package has been written to be easy to use and
essential consists of a single function, `outstandR()`. This can be used
to run all of the different types of model, which we will call
*strategies*. The first two arguments of `outstandR()` are the
individual and aggregate-level data, respectively.

A `strategy` argument of `outstandR` takes functions called
`strategy_*()`, where the wildcard `*` is replaced by the name of the
particular method required, e.g. `strategy_maic()` for MAIC. Each
specific example is provided below.

The formula used in this model, passed as an
argument to the strategy function is

```{r}
lin_form <- as.formula("y ~ X3 + X4 + trt*X1 + trt*X2")
```

### MAIC

As mentioned above, pass the model specific strategy function to the main `outstandR()` function, in this case use `strategy_maic()`.

```{r outstandR_maic}
outstandR_maic <-
  outstandR(ipd_trial, ald_trial,
            strategy = strategy_maic(
              formula = lin_form,
              family = poisson(link = "log")))
```

The returned object is of class `outstandR`.

```{r outstandR_maic-print}
outstandR_maic
```


### Simulated Treatment Comparison (STC)

STC is the conventional outcome regression method. It involves fitting a
regression model of outcome on treatment and covariates to the IPD. Simply pass
the same as formula as before with the `strategy_stc()` strategy function.

```{r outstandR_stc}
outstandR_stc <-
  outstandR(ipd_trial, ald_trial,
            strategy = strategy_stc(
              formula = lin_form,
              family = poisson(link = "log")))
outstandR_stc
```


### Parametric G-computation with maximum-likelihood estimation

G-computation marginalizes the conditional estimates by separating the
regression modelling from the estimation of the marginal treatment
effect for *A* versus *C*.
Pass the `strategy_gcomp_ml()` strategy function.


```{r outstandR_gcomp_ml, message=FALSE, warning=FALSE}
outstandR_gcomp_ml <-
  outstandR(ipd_trial, ald_trial,
            strategy = strategy_gcomp_ml(
              formula = lin_form,
              family = poisson(link = "log")))
outstandR_gcomp_ml
```

### Bayesian G-computation with MCMC

The difference between Bayesian G-computation and its maximum-likelihood
counterpart is in the estimated distribution of the predicted outcomes.
The Bayesian approach also marginalizes, integrates or standardizes over
the joint posterior distribution of the conditional nuisance parameters
of the outcome regression, as well as the joint covariate distribution.

Pass the `strategy_gcomp_stan()` strategy function.

```{r outstandR_gcomp_stan, eval=FALSE, message=FALSE, warning=FALSE}
outstandR_gcomp_stan <-
  outstandR(ipd_trial, ald_trial,
            strategy = strategy_gcomp_stan(
              formula = lin_form,
              family = poisson(link = "log")))
```

```{r outstandR_gcomp_stan_eval, echo=FALSE, message=FALSE, warning=FALSE}
xx <- capture.output(
  outstandR_gcomp_stan <-
    outstandR(ipd_trial, ald_trial,
              strategy = strategy_gcomp_stan(
                formula = lin_form,
                family = poisson(link = "log"))))
```

```{r}
outstandR_gcomp_stan
```

### Multiple imputation marginalisation

Finally, the strategy function to pass to `outstandR()` for multiple imputation marginalisation is `strategy_mim()`,

```{r outstandR_mim, eval=FALSE}
outstandR_mim <-
  outstandR(ipd_trial, ald_trial,
            strategy = strategy_mim(
              formula = lin_form,
              family = poisson(link = "log")))
```

```{r outstandR_mim_eval, echo=FALSE}
xx <- capture.output(
  outstandR_mim <-
    outstandR(ipd_trial, ald_trial,
              strategy = strategy_mim(
                formula = lin_form,
                family = poisson(link = "log"))))
```

```{r}
outstandR_mim
```

### Model comparison

Combine all outputs for relative effects table of all contrasts and methods.

```{r table-res, echo=FALSE}
res_tab <- 
  data.frame(
    # d_true = c(d_AB_true, d_AC_true, d_BC),
    # d_naive = c(d_AB_naive, d_AC_naive$d_AC, d_BC),
    `MAIC` = unlist(outstandR_maic$contrasts$means),
    `STC` = unlist(outstandR_stc$contrasts$means),
    `Gcomp ML` = unlist(outstandR_gcomp_ml$contrasts$means),
    `Gcomp Bayes` = unlist(outstandR_gcomp_stan$contrasts$means),
    `MIM` = unlist(outstandR_mim$contrasts$means)) |> 
  round(2)

res_tab_var <- 
  data.frame(
    # d_true = c(NA, NA, NA),
    # d_naive = c(var.d.AB.naive, d_AC_naive$var_AC, var.d.BC),
    `MAIC` = unlist(outstandR_maic$contrasts$variances),
    `STC` = unlist(outstandR_stc$contrasts$variances),
    `Gcomp ML` = unlist(outstandR_gcomp_ml$contrasts$variances),
    `Gcomp Bayes` = unlist(outstandR_gcomp_stan$contrasts$variances),
    `MIM` = unlist(outstandR_mim$contrasts$variances)) |> 
  round(2)

knitr::kable(res_tab)
```

```{r forest-res, fig.width=8, fig.height=6, warning=FALSE, message=FALSE, echo=FALSE}
library(ggplot2)

var_dat <- 
  t(res_tab_var) |> 
  as.data.frame() |> 
  tibble::rownames_to_column("type") |>
  reshape2::melt(variable.name = "Comparison",
                 value.name = "var")

plotdat <- 
  t(res_tab) |> 
  as.data.frame() |> 
  tibble::rownames_to_column("type") |>
  reshape2::melt(variable.name = "Comparison",
                 value.name = "Estimate") |> 
  mutate(id = 1:n(),
         type = as.factor(type)) |> 
  merge(var_dat) |> 
  mutate(lo = Estimate + qnorm(0.025) * sqrt(var),
         hi = Estimate + qnorm(0.975) * sqrt(var))

ggplot(aes(x = Estimate, y = id, col = type), data = plotdat) +
  geom_vline(xintercept = 0, lty = 2) +
  geom_point(size = 2) +
  geom_segment(aes(y = id, yend = id, x = lo, xend = hi), na.rm = TRUE) +
  xlab("Estimate (Log RR)") +
  facet_grid(Comparison~., switch = "y", scales = "free_y", space = "free_y") +
  scale_y_reverse(name = "Comparison in BC population",
                  breaks = NULL, expand = c(0, 0.6))
```
